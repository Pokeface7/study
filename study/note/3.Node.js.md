#                 Node.js

## 一、Node.js和js对比

Node.js是js运行在后端的环境，使用这个环境可以进行后端开发，实现Java，Python等后端语言同样的功能

#### 1、对比js

​       js运行在客户端浏览器，Node.js运行在后端（服务器端）；

​        js存在多款浏览器有代码兼容性问题，Node.js只有一种环境不存在代码兼容性问题；

​        js和Node.js斗鱼相同的自定义对象和内置对象，不同的宿主对象；

​        js用于开发浏览器端的交互效果，Node.js用于服务器端开发，例如：数据库访问，调用其他服务器....

#### 2、安装

#### 3、运行js

脚本模式

​       node  拖拽文件  回车  运行

交互模式

​         node 回车  进入交互模式

连续两次Ctrl+C 或者一次Ctrl+D 退出交互模式

## 二、全局对象——global

全局对象：可以在任意作用域使用的变量

可以用来检测一个变量或者函数是否为全局

**浏览器下的global改名字为window**

练习：编写js和html，把js嵌入到html中，在js声明变量，创建函数；使用window检测是否为全局变量

**浏览器：每个js文件下是在全局作用域，存在全局污染**

**Node.js：每个js文件都是在一个独立的文件作用域，不存在全局污染**

变量在一个模块作用域下，属于局部变量，外部无法访问

## 三、模块

​        在Node.js下，每一个文件就是一个模块

项目中需要哪些文件，都需要把文件引入进来

//引入同一级目录下的模块,后缀名.js可以省略
//下一级./a/1.js
//同一级目录./
//上一级目录../
//上上级目录../../

### 1.模块系统

require（）  用于引用其他的模块，同一级路劲的文件需要加  ./ 

module.exports  当前模块暴露的对象，默认是一个空对象，如果需要哪些内容，需要添加到这个对象下 

引入模块： 

![image-20220318102613041](D:\WEBStudyRecord\Notes\typora-images\image-20220318102613041.png)

```
/*
module.exports={
	 fn:fn,
	 fn1:fn1,
    p:person
	}
	*/
//只是暴露person对象这一个出去
//直接把暴露的对象赋给module,exports
module.exports=person;
```

### 2、模块分类

分为自定义模块、核心模块、第三方模块

|          | 以路径开头                                                   | 不以路径开头                                                 |
| -------- | ------------------------------------------------------------ | :----------------------------------------------------------- |
| 文件模块 | require('./circle.js')<br />用于引入自定义模块               |                                                              |
| 目录模块 | require('./03_tao')<br />会到目录下去寻找package.json中main属性对应的文件，如果找不到获取默认查找index.js； | require('tao')<br />会到当前目录下的node_modules目录中寻找tao模块，如果找不到会一直往上一级的node_modules目录寻找；常用于引入第三方模块。 |

json文件，是一种存数据的文件，只能放数组或者对象；对象的属性名必须加双引号，值是字符串也必须用双引号{“a”:"tao"}

### 3、包和npm

CommonJS:是一套模块化的规范，Node.js引入模块和暴露对象都是基于这个规范。

Node.js就是使用的这套模块化规范。

包：package，指的是第三方模块

npm:用来管理包的工具，例如：下载、上传、升级、卸载...在Node.js安装的时候就已经附带安装了。www.npmjs.com

#### 1、npm命令

www.npm.js.cn

npm   init                           一直回车，用于创建package.json文件，作为项目描述文件

npm install  + 模块名称               下载安装指定的模块，会将模块下载在node_modules目录下，如果目录不存在会自动创建。同时会下载其他依赖的包。生成文件package_lock.json，用于记录所有包的信息。

npm install          会自动的去下载package-lock.json和package.json中记录的包，如果node_modules被删除了，可重新下载回来。

### 4、核心模块——查询字符串模块（querystring）

核心模块会自动到安装目录下去寻找

nodejs中文文档：www.nodejs.cn

查询字符串：浏览器端向服务器端传递参数的一种形式，位于网址中

通过？分隔后面是查询字符串，查多个用&隔开

![image-20220318173948277](D:\WEBStudyRecord\Notes\typora-images\image-20220318173948277.png)



查询字符串模块：querystring    ，Node.js下专门用于操作查询字符串的工具，可以获取传递的参数

parse()   将查询字符串转为对象，可以获取传递的值

```
//引入查询字符串模块（核心模块）
const querystring=require('querystring');//
console.log(querystring);
//查询字符串
 var str='kw=美丽的泡沫&a=只一刹那花火';
 //获取传递的值,使用引入的模块中提供的方法
 //parse是里面提供的一种方法，将查询字符串转为对象
 var obj=querystring.parse(str);
 console.log(obj);
 console.log(obj.kw,obj.a);
```

练习：获取以下查询的字符串的值'user=tao&pwd=123456'，最后打印以下格式

登陆成功！用户名：  密码：

```
const querystring=require('querystring');
 var str='user=tao&pwd=123456';
 var obj=querystring.parse(str);
 console.log(`登录成功！ 用户名：${obj.user} 密码：${obj.pwd}`);
```

### 5、网址模块（URL）

网址（URL）：统一资源定位，互联网上的任何资源都有对应的网址；最终通过网址获取服务器端的资源

![image-20220318173519010](D:\WEBStudyRecord\Notes\typora-images\image-20220318173519010.png)

new URL(网址)   将一个网址转为对象，目的为了获取各个部分

```
//URL
 var str='http://www.codeboy.com:9999/1.html?kw=小米';
 //获取URL中的各部分
 //可以把URL转为对象
 var obj=new URL(str);
 //console.log(obj);
 //获取查询字符串部分
 var str1=obj.searchParams;
 console.log(str1);
 //获取查询字符串传递的值
 console.log(str1.get('kw'));
```

练习：‘班级编号：WEB      课程名称：‘

```
var str='https://www.tmooc.cn:443/course/web.html?cid=2202&cname=Nodejs';//网址
var obj=new URL(str);//将网址转为对象，可以获取各部分
var obj1=obj.searchParams;//获取查询字符串功能
console.log(`班级编号：WEB${obj1.get('cid')} 课程名称：${obj1.get('cname')}`);//通过get调用函数获取值
```

cmd操作：node  文件开头+Tab+回车

### 6、全局模块

也称全局对象：不需要引入就可以直接使用的模块

#### 1、console模块

提供了一组用于控制台输出的方法

console.log(1);//打印日志
console.info(2);//打印消息
console.warn(3);//打印警告
console.error(4);//打印错误
console.tiem();//开始计时
console.timeEnd();//结束计时

注意：开始和结束里面的参数要一致

#### 2、process模块

进程：系统上的每个软件运行都是代表一个进程，进程占用一定的CPU、内存

process.arch    查看当前CPU架构

process.platform  查看当前的操作系统

process.pid   查看当前进程的编号，随机生成

process.kill()    用于结束指定编号的进程

#### 3、Buffer模块

缓冲区：是内存中的一块区域，用于临时存储数据

Buffer.alloc(字节数，’内容‘)

toString()        将Buffer数据转为字符串，前提是存储的是字符串

```
//创建Buffer,分配空间
//一个汉字占3个字节
var buf=Buffer.alloc(37,'雨后有车驶来,驶入暮色苍白');//<Buffer e9 9b a8 e5 90 8e e6 9c 89 e8 bd a6 e9 a9 b6 e6 9d a5 2c e9 a9 b6 e8 bf 87 e6 9a ae e8 89 b2 e8 8b 8d e7 99 bd>buffer数据
console.log(buf);
//将Buffer数据转为字符串
console.log(buf.toString());
```

#### 4、timer模块（定时器）

提供了一组全局函数

##### 1、一次性定时器

```
开启
var timer=setTimeout(回调函数，间隔时间)
当间隔时间到了，调用一次函数；单位是毫秒；
清除：clearTimeout(timer)
```

##### 2、周期性定时器

```
var timer=setInterval(回调函数，间隔时间)
每隔一段时间调用一次函数
清除
clearInterval(time)
```

##### 3、立即执行的定时器

```
//JS执行方式：单线程：所有程序都是从上到下
console.log(2);
//立即执行定时器
setImmediate(function(){
     console.log('1');//事件队列
});
//另一个立即执行的定时器,进入事件队列时，优先级大于setImmdeiate,会出现在它前面
process.nextTick(function(){
    console.log(4);
});
console.log(3);
打印顺序是：2341
```

定时器：所有的定时器都会进入到事件队列执行；

事件队列：由一组排队执行的回调函数组成，只有执行完主程序才会执行事件队列；

![image-20220321145711483](D:\WEBStudyRecord\Notes\typora-images\image-20220321145711483.png)

#### 6、同步和异步

同步：在主程序执行；同步的方法通过返回值获取结果

异步：会产生回调函数，并放入到事件队列中；只有主程序执行完才会执行；所有的定时器函数，Node.js下提供的带有回调函数的函数都是异步的。定时器特殊，会直接放到事件队列，而Node.js下提供的异步方法会在一个独立的线程执行，最后通过回调函数获取结果。

#### 7、文件系统模块

用于文件的操作

文件分为目录形式和文件形式

使用这个模块(fs)，必须先引入

##### 1、查看文件的状态

###### 1、同步（带Sync）

statSync(文件的路径)/stat(文件的路径，回调函数)

​     isDirectory()      是否为目录

​       isFile()               是否为文件

```
//引入文件系统模块(fs)
const fs=require('fs');
//查看文件的状态：目录形式还是文件形式，文件的大小
//sync  同步
var a=fs.statSync('./03_timer.js');
console.log(a);
//是否为目录
console.log(a.isDirectory());
//是否为文件
console.log(a.isFile());
```

###### 2、异步（带回调函数callback）

在执行异步方法stat的时候，会从线程池中获取一个线程执行这个任务，执行完以后的结果是以回调函数的形式出现，然后再把回调函数放入到事件队列；等主程序执行完再执行事件队列的时候，就可以获取结果；同时会把线程放回到线程池；

![image-20220321164550773](D:\WEBStudyRecord\Notes\typora-images\image-20220321164550773.png)

```
const fs=require('fs');
fs.stat('../day02',function(err,s){
//回调函数中包含了文件的状态
//结果有可能是错误，有可能是成功
//形参err,名字可以改，代表可能产生的错误;
//形参s,名字可以改，代表产生的成功结果;
if(err){
 throw err;//抛出错误，出现错误会阻止后面代码执行；
}
console.log(s);
});
console.log('2');//先打印2在执行回调函数
```

##### 2、创建目录

mkdirSync(目录的路径)/mkdir(目录的路径，回调函数)

同步

```
const fs=require('fs');
fs.mkdirSync('./2');
```

异步

```
const fs=require('fs');
fs.mkdir('./1',function(err){
//第一个参数，err可能出现的错误
//第二个参数，只有成功的结果是数据才需要设置
   if(err){
   throw err;
   }
   console.log('创建成功');
});
```

##### 3、移除目录

rmdirSync(目录的路径)/rmdir(目录的路径，回调函数)

只能移除空目录，如果里面有文件是无法成功的；

同步

```
const fs=require('fs');
fs.rmdirSync('./1');
console.log('移除成功');
```

异步

```
const fs=require('fs');
fs.rmdir('./2',function(err){
      if(err){
	  throw err;
	  }
	  console.log('移除成功');
})
```

##### 4、读取目录

1、读取目录 readdir(目录的路径，回调函数)/readdirSync(目录的路径)

同步

```
const fs=require('fs');
var arr=fs.readdirSync('../day02')
console.log(arr);
```

异步

```
const fs=require('fs');
//读取目录
//异步
fs.readdir('../day03',function(err,arr){
   if(err){
   throw err;
   } 
    //arr读取成功的结果
	console.log(arr);
});
```

##### 5、清空写入文件

writeFile(文件的路径，写入的数据，回调函数)/writeFileSync(文件的路径，写入的数据)

如果文件不存在先创建文件，然后写入数据；

如果文件已经存在，先清空文件内容，然后写入数据；

同步

```
const fs=require('fs');
fs.writeFileSync('./1.txt','雨后有车驶来，驶过暮色苍白。旧铁皮往南开，恋人已不在。')
```

异步

```
const fs=require('fs');
fs.writeFile('./1.txt','雨后有车驶来，驶过暮色苍白。旧铁皮往南开，恋人已不在。',function(err){
if(err){
   throw err;
}
console.log('写入成功');
});
```

##### 6、追加写入文件

appendFile(文件的路径，写入的数据，回调函数)/appendFileSync(文件的路径，写入的数据)

如果文件不存在先创建文件，然后写入数据；

如果文件已经存在，在文件的末尾追加数据；

练习：遍历数组，将数组元素写入文件

```
var arr=['迪迦','赛文','雷欧','泰罗','佐菲'];
const fs=require('fs');
for(var i=0;i<arr.length;i++){  
fs.appendFile('./2.txt',arr[i]+'\n',function(err){
if(err){
   throw err;
       }
console.log('写入成功');
   });
}
```

##### 7、读取文件

readFile(文件的路径，回调函数)/readFileSync(文件的路径)

同步

const fs=require('fs');
var a=fs.readFile('./2.txt');
console.log(a.toString());

异步

```
const fs=require('fs');
fs.readFile('./2.txt',(err,s)=>{
if(err){
   throw err;
       }
console.log(s.toString());//读取到的是编码，转为字符串
});
```

##### 8、删除文件

unlink(文件的路径，回调函数)/unlinkSync(文件的路径)

```
const fs=require('fs');
fs.unlink('./1.txt',(err)=>{
   if(err){
	   throw err;
	   }
   console.log('删除成功');
});
```

##### 9、检测文件（目录）是否存在

existsSync(文件路径)  只有同步方法

```
//练习：如果文件存在，则删除文件 unlink
//练习：如果目录不存在，则创建   mkdir
const fs=require('fs');
//var b=fs.existsSync('./1');
//console.log(b);
if(fs.existsSync('./1.txt')){
fs.unlinkSync('./1.txt');
}
if(！fs.existsSync('./mydir')){fs.mkdirSync('mydir');}
```

10、拷贝文件

copyFile(源文件，目标文件，回调函数)copyFileSync(源文件，目标文件)

如果要拷贝到其他目录，先写目录路径再写目标文件

```
const fs=require('fs');
fs.copyFile('./1.txt','./mydir/3.txt',(err)=>{
if(err){
   throw err;
}
});
```

## 三、文件流（stream）

可以把文件分成很多段

createReadStream()  创建可以读取的文件流

createWriteStream()  创建可以写入的文件流

pipe()   管道，可以将读取的流添加到写入的流，最终完成文件拷贝

on  (事件名称，回调函数)         添加事件，用于监听某一个操作，一旦监听到会自动调用回调函数；事件名称是固定的字符串形式。

```
const fs=require('fs');
//var count=0;
//使用流的方式读取文件
var rs=fs.createReadStream('./1.rar');
//使用流的方式写入文件，会创建空文件
var ws=fs.createWriteStream('./2.rar');
//把读取的流添加到写入的流,pipe管道
rs.pipe(ws);
/*
//获取每一段数据
//监听是否有数据流入到内存，通过事件方式，一旦有数据流入内存，会自动以回调函数获取
//data 是固定的字符串形式，表示数据流入
rs.on('data',(c)=>{
//c代表每一段数据
console.log(c);
count++;
})
//在整个读取结束后再打印总数
//添加事件，监听是否读取结束，UI单读取结束会自动调用回调函数
//end 事件名称表示读取结束
rs.on('end',()=>{
    console.log(count);
})
*/
```

## 四、http协议

![image-20220322175802614](D:\WEBStudyRecord\Notes\typora-images\image-20220322175802614.png)

WEB服务器：为浏览器提供资源的服务器，例如：网页，图片，数据

HTTP协议：超标文本传输协议，是浏览器和WEB服务器之间的通信协议

1、通用头信息

既包含一部分请求的也包含一部分响应

Request URL :要求请求的资源

Request  Method:请求的方法，对资源的操作方式，get/post

Status Code ：响应的状态码

1**：接收到了请求，还没有结束响应

2**：成功的响应

3**：响应的重定向，会跳转到其他的资源

4**：客户端错误

5**：服务器端错误

2、响应头信息（Response）

服务器端发出的

Location：设置要跳转的URL，通常结合着状态码使用

Content-Type：响应的内容类型，解决中文乱码  'text/html;charset=utf-8'

3、请求头信息（request）

浏览器端发出的

## 五、http模块

使用http模块可以创建WEB服务器，为浏览器提供服务

1、创建服务器

2、接收请求，做出响应

```
//引入http模块
const http=require('http');
//创建WEB服务器
const app=http.createServer();
//设置端口为3000
app.listen(3000,()=>{
console.log('启动成功');
});
//请求WEB服务器
//IP地址
//http://127.0.0.1:3000
//域名
//http://localhost:3000
//接受请求，做出响应
//通过事件，监听请求，并做出响应
app.on('request',(req,res)=>{
//req代表请求的对象
//res 代表响应的对象
//设置响应的头信息
res.setHeader('Content-Type','text/html;charset=utf-8');
//设置响应到浏览器的内容
res.write('不满十八岁自觉退出');
//结束并发送响应
res.end();
})
```

res 响应的的对象    

setHeader()/write()/end()

​     res.statusCode=值       设置响应的状态码

req 请求的对象       

req.url    获取请求的服务器端资源    是字符串型形式

req.method   请求的方法

练习：编写文件02， 创建服务器，根据请求来作出响应

响应‘登录成功                ‘/login’

跳转到tmooc网址             ‘/study’

响应404  Not  Found’     其他

```
const http=require('http');
const app=http.createServer();
app.listen(3000);
app.on('request',(req,res)=>{
   if(req.url==='/login'){
     res.setHeader('Content-Type','text/html;charset=utf-8');
     res.write('登录成功');
     }else if(req.url==='/study'){
        res.statusCode=302;
   res.setHeader('Location','https://www.tmooc.cn/')
     }else{
	 res.statusCode=404;
	 res.write('Not Found');
	 }
	 res.end();
});
```

## 六、框架

：是一整套解决方案，简化了已有的功能，添加了之前没有的功能，专门用于项目开发，任何的语言开发项目都会选择使用框架

Node.js：express koa egg

前端：Vue React  Angular

Java：Spring

### 1、express框架

基于Node.js平台，快速、开放、极简的WEB开发框架

属于是第三方模块(包)，需要先去下载安装

npm  install  express

#### 1、创建WEB服务器

引入下载的模块、创建WEB服务器、设置端口

#### 2、路由

用来监听处理不同的请求，路由包含三部分：请求的方法、请求的URL、回调函数

##### 1、响应的对象

res.send()  设置响应的内容并发送

res.redirect()   设置响应的重定向并发送

res.senfFile()   设置响应的文件并发送，使用绝对路径

绝对路径   __dirname+'/文件名称'  注意两个`_`



```
//引入express第三方模块
const express=require('express');
//console.log(express);
//创建WEB服务器,
const app=express();
//设置端口
app.listen(3000);
//添加路由
//监听登录的请求（请求的方法get  请求的URL：/login）
app.get('/login',(req,res)=>{
//不同于之前http模块下的对象，比之前更强大
//设置响应的内容并发送
res.send('登录成功');
});
app.get('/study',(req,res)=>{
//设置响应的重定向并发送
res.redirect('https://www.huya.com/');
});
app.get('/',(req,res)=>{
res.redirect('/login');
});
//添加路由(请求方法：get 请求URL:/index)
app.get('/index',(req,res)=>{
//响应1.html文件并发送,使用绝对路径
res.sendFile(__dirname+'/1.html');
});
//获取当前模块的绝对路口，通过局部变量，每个模块下都有
//console.log(__dirname);两个_
```

##### 2、请求的对象

req.method     获取请求的方法

req.url    获取请求的URL

**req.query   获取get传递的参数，并转为对象**

req.params   获取路由传递的参数，并转为对象

| 传参方式 | 格式                                     | 路由获取                                  |
| -------- | ---------------------------------------- | ----------------------------------------- |
| get传递  | http://127.0.0.1:3000/mysearch?kw=笔记本 | req.query{kw:'笔记本'}                    |
| 路由传参 | http://127.0.0.1:3000/detail/10          | ①现指定参数名称<br />②req.params{id:数值} |

练习：路由传参

```
//引入
const express=require('express');
//创建服务器
const app=express();
//端口
app.listen(3000);
//创建路由，监听请求，路由传参
app.get('/shopping/:pname',(req,res)=>{
	console.log(req.params.pname);
    res.send('添加成功，商品名称:'+req.params.pname);
});
```

练习：get传参

```
//引入
const express=require('express');
//创建服务器
const app=express();
//端口
app.listen(3000);
//路由接收请求，get传参，响应登录
app.get('/login',(req,res)=>{
   res.sendFile(__dirname+'/login.html');
});
//获取传递的参数
app.get('/mylogin',(req,res)=>{
res.send(`登录成功!<br>
	  欢迎:${req.query.user}<br>
      密码:${req.query.pwd}`);
});
```

#### 3、post传参

相对安全，不会将数据暴露在URL；没有大小限制，可以传递字符串，也可以传递大文件；

现阶段发送post请求，只能采用表单提交；

在路由之前设置，将post传递的参数转为对象

```
app.use(express.urlencoded({
  extended:true  //内部如何转为对象，是否使用第三方模块

}))
//在路由获取
req.body
```

```
const express=require('express');
const app=express();
app.listen(3000);
app.get('/reg',(req,res)=>{
    res.sendFile(__dirname+'/01_reg.html');
});
//需要提前将post请求转为对象
app.use(express.urlencoded({
//内部是如何转对象
 extended: true  //是否使用第三方模块转对象
}));
//添加路由，监听按钮提交的请求，post传递的参数
app.post('/myreg',(req,res)=>{//html里面也要改为post
	//获取post传递的参数
	console.log(req.body);//使用body必须要将post请求转对象
  res.send('注册成功!');
});

```

#### 4、路由器

![image-20220324141904815](D:\WEBStudyRecord\Notes\typora-images\image-20220324141904815.png)

用于将所有的路由按照不同的功能模块进行分类，目的是便于管理路由；

##### 1、路由器

创建路由器对象

添加路由

暴露路由器对象

```
//引入
const express=require('express');
//创建
const r=express.Router();
//往路由器下添加路由
//删除用户（get /delete）
r.get('/delete',(req,res)=>{
   res.send('用户删除成功');
});
//将路由器对象暴露出去，外部才可以使用
module.exports=r;
```

##### 2、WEB服务器中使用

引入路由器

app.use(要添加的前缀，要引入的路由器)

使用路由器，就会将所有的路由器的路由挂载到WEB服务器；同时给路由添加前缀

```
//引入express模块
const express=require('express');
  //引入用户路由器模块
const userRouter=require('./02_user.js');
 //创建服务器
const app=express();
 //设置端口
app.listen(3000);
 //使用路由器，才会将所有的路由挂载到WEB服务器下
 //同时可以给所有路由中URL添加前缀，防止多个路由冲突;
app.use('/user',userRouter);
  //添加前缀后/delete变成/user/delete;
```

### 2、中间件

中间件是用于拦截对WEB服务器的请求

express在中间件分为应用级中间件、路由级中间件、内置中间件、第三方中间件、错误处理中间件

#### 1、应用级中间件

也称为自定义中间件，就是一个函数，一旦拦截到会自动调用

中间件函数：function fn(req,res,next){

next();//往后执行下一个中间件或者路由

}

app.use(拦截的URL,fn);

```
//引入express模块
const express=require('express');
//创建WEB服务器
const app=express();
//设置端口
app.listen(3000);
function fn(req,res,next){
// console.log('拦截到了请求');
//获取get传递的参数{user:''}
console.log(req.query);
//验证用户是否为管理员,如果不是管理员root，响应'请提供管理员身份'，否则是管理员，才允许往后请求路由器；
if(req.query.user!=='root'){
    res.send('请提供管理员身份');
}else{
    //往后执行，可能是下一个中间件，也可能是路由
    next();
}
}
//添加中间件，拦截对list 的请求;一旦拦截会调用函数
app.use('/list',fn);
//路由（get/list ），响应所有后端的用户列表
app.get('/list',(req,res)=>{
   res.send('这是用户列表，只有管理员有权限查看');
});
app.use('/delete',fn);
app.get('/delete',(req,res)=>{
   res.send('商品删除成功')
});
```

#### 2、路由级中间件

路由器的使用就是

app.(拦截的URL，路由器)

不写要拦截的url，表示拦截所有的post请求

#### 3、内置中间件

指的是express提供的中间件，可以直接使用

##### 1、将post传递的参数转为对象

app.use(express.urlencoded)

app.use(express.urlencoded({
	extended: true  //是否引入第三方模块
}));

##### 2、托管静态资源

静态资源：指的是固定的文件；例如：html、css、js、图像....

托管静态资源，如果浏览器要请求静态资源，不需要通过路由响应，而是让浏览器自动去到某个目录下寻找文件。

app.use(express.static('要托管的目录'))

 

练习：练习：创建web服务器，托管静态资源到public目录，在目录下创建文件login.html，点击提交向服务器发请求(post  /mylogin)，响应‘登录成功  欢迎：xxx’；  添加中间件拦截对/mylogin的请求，如果用户名不是root，响应‘该用户不可用’，否则往后执行。

```
//引入express模块
const express=require('express');
//创建WEB服务器
const app=express();
//设置端口
app.listen(3000);
//托管静态资源
app.use(express.static('public'));
//建立函数
function fn(req,res,next){
    if(req.body.user!=='root'){
       res.send('请提供管理员身份');
	   //console.log(req.body.user);
	}else{
		next();
	}
}
//将post传递的参数转为对象
app.use(express.urlencoded({
	extended: true  //是否引入第三方模块
}));
//添加中间件，拦截对mylogin的请求
app.use('/mylogin',fn);
//添加路由(post /mylogin)，监听按钮提交的请求
app.post('/mylogin',(req,res)=>{
//获取post传递的参数
    res.send('登录成功！欢迎：'+req.body.user);
});
```

执行流程：

浏览器发出请求——>中间件（将post传递的参数转为对象）——>中间件（检测post传递的参数是否需要拦截）——>路由

## 七、Mysql模块

Node.js下专门用于操作mysql的模块

属于第三方模块需要先下载安装

npm  install mysql

createConnection()  创建普通连接

createPool();   创建连接对象，产生一组连接

query(SQL命令,数组，回调函数)   执行SQL命令，通过回调函数获取结果，数组用于对数据进行过滤，过滤后再去替换占位符（?）

SQL注入：是对数据库的攻击方式，破坏了原有的SQL命令，添加新的命令

```
var str='tao" or "1';
//select * from emp where ename="tao" or "1"
```

mysql模块下解决SQL注入，

练习：假设获取了一组员工的数据，格式为对象，包含的属性有姓名，性别，生日，工资，部门编号；执行SQL命名，将这条数据插入到数据表emp;

```
 //插入数据
var obj={
    ename:'tao',
	 sex:1,
	 birthday:'1997',
	 salary:6000,
	 deptid:20
}
pool.query('insert into emp set?',[obj],(err,s)=>{
if(err){
    throw err;
   }
   console.log(s);
});*/
//删除指定编号
var eid=1;
pool.query('delete from emp where eid=?',[eid],(err,s)=>{
if(err){
    throw err;
   }
   console.log(s);
   //添加判断，如果删除成功，打印'删除成功'，否则打印'删除失败'
   //结果是对象，如果独享下的affectedRows(受影响的行数)属性值为0 说明失败，否则成功
   if(s.affectedRows===0){
   console.log('f');
   }else{
   console.log('s');
   }
});
```

## 八、数据接口（RESTful规范接口）

后端为前端提供的动态资源

每次写的一个路由就是一个接口

登录接口

 接口地址：http://127.0.0.1:3000/mylogin

请求方式;post 

传递的参数:用户名、，密码

返回结果：登录成功，欢迎

### 1、接口地址

代表的是要请求的资源

http://127.0.0.1:3000/v1/users/login

​                                     版本号/资源名称(复数)/对资源特殊操作

### 2、请求方法

对应的是资源的操作方式——增删改查

post  插入数据

delete 删除数据

put  修改数据

get 查询数据

### 3、传参方式

1、操作单个资源，使用路由传参

http://127.0.0.1:3000/v1/users/2

2、添加和修改使用post传参

传参的时候需要在APIPost中的body上添加，别的传参不需要，直接在？后面写

3、从一组数据总进行过滤，例如分页，使用get传参

http://127.0.0.1:3000/v1/users?pno=1&count=10

过滤出工资在6000-8000

http://127.0.0.1:3000/v1/emps?s1=6000&2=8000

### 4、返回结果

json——字符串形式的对象，属性名必须用双引号，属性值是字符串的话必须用双引号，包含一个人规定的状态码

{“code”:200 ,"msg":"登录成功"}

{“code”:500 ,"msg":"登录失败"}

```
//；练习：编写文件，创建WEB服务器，添加员工路由（接口）（请求方法：post，请求的URL：/v1/emps）,响应{"code":200,"msg":"登录成功"}
//引入express模块
const express=require('express');
//创建WEB服务器
const app=express();
//设置端口
app.listen(3000);
//添加员工接口(post   /v1/emps)
//接口地址http://127.0.0.1:3000/v1/emps
//请求方式post
app.post('/v1/emps',(req,res)=>{
//send 方法会自动将对象转为json{"code":200,"msg":"登录成功"}
	  res.send({code:22,msg:'登录成功'}
});
```

OkPacket {
  fieldCount: 0,字段数
  affectedRows: 1,受影响的行
  insertId: 22,
  serverStatus: 2,服务器状态
  warningCount: 0,警示数
  message: '',信息
  protocol41: true,
  changedRows: 0
}

练习：接口

```
//；练习：编写文件，创建WEB服务器，添加员工路由（接口）（请求方法：post，请求的URL：/v1/emps）,响应{"code":200,"msg":"登录成功"}
//引入express模块
const express=require('express');
//引入mysql模块
const mysql=require('mysql');
//创建WEB服务器
const app=express();
//设置端口
app.listen(3000);
//创建连接池对象
const pool=mysql.createPool({
 host:'127.0.0.1',
 port:'3306',
 user:'root',
 password:'',
 database:'tedu',//进入的数据库
 connectionLimit:15//连接池的数量，默认15
});
//将post传递的参数转为对象
app.use(express.urlencoded({
	extended:true
}));
//添加员工接口(post   /v1/emps)
//接口地址http://127.0.0.1:3000/v1/emps
//创建接口，请求方式post
app.post('/v1/emps',(req,res)=>{
	//获取传递的参数，需要添加中间件，转对象
    console.log(req.body);
//执行SQL命令，将数据插入到数据库
pool.query('insert into emp set?',[req.body],(err,r)=>{
    if(err){
		throw err;
		}
		console.log(r);
		//插入数据，拿到成功的结果，才能响应
//send 方法会自动将对象转为json{"code":200,"msg":"登录成功"}
	  res.send({code:200,msg:'登录成功'})
})
});
//删除员工接口(delete /v1/emps)
//接口地址http://127.0.0.1:3000/v1/emps
//创建接口请求方式delete
app.delete('/v1/emps/:eid',(req,res)=>{//添加/:eid，接收参数
console.log(req.params);//传过来的是eid:5,想要获取值要写成[req.params.eid]
//执行SQL命令，删除编号对应的员工，判断是否成功
  pool.query('delete from emp where eid=?',[req.params.eid],(err,r)=>{
   if(err){
   throw err;
   }
	console.log(s);
//判断是否成功
//结果是对象，如果对象下的属性affectedRows的值是0说明失败，否则成功
  if(r.affectedRows!==0){
   res.send({code:200,msg:'删除成功'});
  }else{
   res.send({code:500,msg:'删除失败'});
  }
 });
});
```

### 错误处理中间件

```
app.use((err,req,res,next)=>{
 if(err){错误处理的信息
  res.send({code:502,msg:'服务器错误'});
 }
});
```

![image-20220326153743103](D:\WEBStudyRecord\Notes\typora-images\image-20220326153743103.png)

练习：1、在app.js下创建WEB服务器2、在用户路由器user,js下，创建路由器对象，添加用户注册的路由（post /reg）,将路由器对象暴露出来。3、在app.js中引入用路由器（路径），使用路由器，添加前缀/v1/users；4、测试接口5、获取post传递的参数6、在pool.js中创建连接池对象，暴露出去7、在user.js中引入连接池模块(../pool.js)执行SQL命令，将数据插入数据库

## 九、正则表达式

第一位：1；第二位：3~9；第三位：0~9；

字符串格式规则

[]字符集，可以作为备选方案

量词：正则表达式中规定字符集出现次数的

```
var phone='17855527556'
//使用正则表达式去验证一个手机号码
//console.log();
if(!/^1[3-9]\d{9}$/.test(phone)){
console.log('手机号码格式错误');
}
```

服务器端

```
//引入express模块
const express=require('express');
//引入用户路由器模块
const userRouter=require('./router/user.js');
//创建服务器
const app=express();
//设置端口
app.listen(3000);
//将post传递的参数转为对象
app.use(express.urlencoded({extended:true}));
//使用路由器,将所有的路由挂载到WEB服务器
//给用户路由器下所有的路由添加前缀/v1/users
app.use('/v1/users',userRouter)
//在所有路由的后面，添加错误处理中间件，拦截所有路由的错误
app.use((err,req,res,next)=>{
 if(err){
//console.log(err);
//响应服务器端错误
  res.send({code:502,msg:'服务器错误'});
 }
});
```

用户模块

```
//引入express模块
const express=require('express');
//引入连接池
const pool=require('../pool.js');
//创建路由器对象
const userRouter=express.Router();
//添加路由(用户注册接口)(post  /reg)
//接口的地址:/v1/users/reg;接口的请求方式:post
userRouter.post('/reg',(req,res,next)=>{
//获取post传递的参数
  var obj=req.body;
  console.log(obj);
//验证手机格式是否正确，如果不正确
//{code:405,msg:'手机格式不正确'}
   if(!/^1[3-9]\d{9}$/.test(obj.phone)){
   res.send({code:405,msg:'手机格式不正确'});
   return;//必须要加return，否则会继续执行，一个send调用表示已经响应了，不允许再次响应；
}
//执行SQL命令,将数据插入到数据库
  pool.query('insert into xz_user set?',[obj],(err,r)=>{
  if(err){
  //throw err;//会阻止后面程序执行，服务器崩溃，一般不使用
  //交给下一个错误处理中间件,同时把错误信息传递过去
   next(err);
  //阻止往后执行,后面阻止响应
   return;
  }
  console.log(r);
//成功以后，代表插入成功，再去响应
  res.send({code:200,msg:'注册成功'});
  })  
});
//暴露出去
module.exports=userRouter;
```

连接池模块

```
//引入mysql模块
const mysql=require('mysql');
//创建连接池
const pool=mysql.createPool({
host:'127.0.0.1',
port:'3306',
user:'root',
password:'',
database:'xz',
connectionLimit:15
});
module.exports=pool;
```

## 十、GIT

vcs系统：用于项目中文件的存储、合并、回退、代码追踪等功能

常用的vcs软件

CVS 2000之前

SVN 2010以前

GIT 2010以后

命令行输入git --verdion

### 1、GIT种常见的概念

工作目录：是一个目录，用于保存项目中的所有的 文件

暂存区：是内存中的一个区域，用于临时存储文件的变化

GIT仓库：是一个特殊的目录，保存项目中所有的文件以及文件的变化

![image-20220328141024741](D:\WEBStudyRecord\Notes\typora-images\image-20220328141024741.png)

### 2.GIT中常见的命令

#### 1、在第一次使用GIT之前

（软件安装之后），告诉GIT系统你是谁

在你工作目录下单击右击打开git

**git  config  --global     user.name   "自定义用户名"**

**git    config    --global    userename   "用户邮箱"**

#### 2、创建GIT仓库

**git      init** 

会在当前的目录下创建.git的目录，用于保存项目中文件的变化

#### 3、查看GIT系统状态

**git     status**

监控文件的变化，例如：新文件、删除了文件、修改了文件

#### 4、将指定的文件添加到暂存区

**git   add   文件名称**

#### 5、将所有新文件、删除文件、修改文件...添加到暂存区

**git      add    .**      

#### 6、将暂存区文件提交到GIT仓库

**git    commit   -m    "提交说明"**

#### 7、查看所有的提交日志

**git  log**      只能查看当前的版本以及之前的版本，不能看之后的

**git   reflog   查看所有的提交和回退**

**清屏：clear**

**esc+:quit   退出日志**

#### 8、历史回退

**git   reset   --hard    提交的id**

#### 9、忽略文件

有些文件不需要提交到git仓库，可以忽略，例如：node_modules

使用任意的编辑器创建文件，保存 为gitignore，将需要忽略的文件名写到gitignore中即可忽略

## 十一、分支

从主线中分离出来，避免影响主线开发，最终实现独立开发最终分支并入到主线GIT中默认只有一个主分支master

![image-20220328165057791](D:\WEBStudyRecord\Notes\typora-images\image-20220328165057791.png)

#### 1、创建分支

**git   branch 分支名称**

#### 2、查看所有的分支

**git  branch**

#### 3、切换分支

**git  checkout  分支名称**

#### 4、合并分支

git  merge  分支名称

![image-20220328173546000](D:\WEBStudyRecord\Notes\typora-images\image-20220328173546000.png)

#### 5、删除分支

git  branch  -d 分支名称     删除已经合并的分支

git  branch  -D  分支名称    强制删除分支，不管是否合并

## 十二、远程仓库

![image-20220328174605934](D:\WEBStudyRecord\Notes\typora-images\image-20220328174605934.png)

码云：www.gitee.com 国内最大

GitHub:www.github.com 全球最大

#### 1、将本地仓库推送到远程仓库

**git   push  远程仓库地址  分支名称**

如果输入错了用户名和密码，需要手动删除，控制面板->凭据管理器->Windows凭据->删除记录

#### 2、克隆一个仓库到本地

git clone 仓库地址

### 3、拉取一个分支到本地

git  pull  仓库地址  分支名称

