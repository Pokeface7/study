# 笔记

注意：HTML标签和属性名是不区分大小写的（js区分），所以浏览器会把任何大写的字符解释为小写。所以使用DOM内的模板时，组件名称 、prop名称、事件名称都需要转换为相应等价的短横线连字符形式。

#### 1、vue.extend:

创建一个子类，让他继承vue上的一些功能

#### 2、require:

实现js文件的异步加载，避免网页失去响应；

#### 3、js中数据类型转为布尔值：

使用！！双感叹号

undefined、null、false、0、NaN、""/'',六种情况为false;其他情况均为true;

！感叹号无法转换为布尔值，翻译为没有；

#### 4、v-loading.fullscreen.lock

fullscreen:全屏

lock：锁定

实现效果：当加载事全屏锁定，不可触发任何事件、及时在有滚动条的情况下事件同样禁止；

#### 5、try语句

包含了一个或者多个语句组成的try块，和至少一个catch或者finally块的其中一个，或者连个兼有；

catch子句包含try块中抛出异常时要执行的语句。你想try语句中的内容成功，如果没有成功，你想控制接下来发生的事情，这时你可以在catch语句中实现，如果在try块中有任何一个语句抛出异常，控制立即转向catch子句，没有异常抛出会跳过catch；finally子句在try和catch之后执行，但是在下一个try声明之前执行，无论是否有异常抛出挥着捕获，他总是执行；

#### 6、letter-spaceing

设置元素的的字母间距

#### 7、axios的拦截器（interceptors）

请求拦截响应拦截：在请求或响应被then和catch处理前拦截

请求拦截器：根据请求的请求头设定来决定哪些请求可以访问；

响应拦截器：根据后端返回的状态码判定执行不同的业务

```
service.interceptors.request.use(
 (config) = > {
  const token = tokenUtils.getToken();
   if (token) {
    if(!config.headers) {
     config.headers = {};
    } 
    config.headers["userToken"] = token;
   }
   return config;
  },
  (error) = > {
   promise.reject(error);
  }
 );
```



#### 8、@command事件

和click都是单击事件，@command可以传递参数

```
handleCommand(command){
 if(command=='logout'){
  localStorage.removeItem('userName')
  this.$router.push('/')
 }
}
```

#### 9、redirect

执行/路由地址时，可以重定向到其他路由地址

#### 10、路由跳转replace

push和replace的区别：push（/path）里面的path会进入路由栈，replace不会，但是他里面的path会替换掉路由栈，里面最后一个路由，所以push可以返回history上一个界面，replace不可以

，返回的是上上个界面；

#### 11、路由配置：

```
import Vue from 'vue' //引入vue
import Router from 'vue-router' //引入vue-router
import Hello from '@component/Hello' //引入根目录下的组件
Vue.use(Router) //全局使用Router
export default new Router({
 routes:[   //配置路径，这是个数组
  { //每个链接都是一个对象
    path:'/' ,  // 链接路径
     name :'Hello',  //路由名称
     component:Hello， //对应的组件模板（正常引入）
     children:[
      {path:'login',component:login}
     ]
  }，
  {
   path:'/word',
   name:'word',
   component:()=> import("@component/Word") //路由懒加载（不需要import组件），首屏组件加在速度更快一些，解决白屏问题
  }
 ]
})
```

二级路由配置

用children属性实现，注意：二级路由路径不用写/,/表示找子路径，这里直接写组件名称即可

#### 12、组件懒加载

```
//常规
<One-com/>
<script>
 import One from './one'
 export default {
  components:{   //要使用一个子组件，我们需要在父组件中导入他，然后再暴露出去
   "One-com":One
  }
 }
</script>
////////////////
懒加载
<One-com/>
<script>
 export default{
  components{
   “One-com":()=>import("./one")
  }
 }
</script>
```

#### 13、组件插槽

父组件可以向子组件传递内容

```
父组件
<template>
 <AlertBox>
 你好//也可以写组件
 </AlertBbox>
</template>
<script>
 import AlertBox from './AlertBox.vue'
 export default {
  components :{AlertBox}
 }
</script>
////
子组件
<template>
 <div>Error</div>
 <solt/>   //占位符，可以将AlertBox标签内容传递过来
</template>
```

默认插槽：如果父组件没有提供插槽内容，可以在slot内添加，会被默认渲染，如果父组件由内容，展示父组件内容

具名插槽：插槽入口处添加v-solt属性或者用#命名，插槽出口slot添加name，可以分别插入内容

```
父组件 入口
<BaseLayout>
    <template #header>
      <h1>Here might be a page title</h1>
    </template>

    <template #default>
      <p>A paragraph for the main content.</p>
      <p>And another one.</p>
    </template>

    <template #footer>
      <p>Here's some contact info</p>
    </template>
  </BaseLayout>
  ///
  子组件出口
  <div class="container">
    <header>
      <slot name="header"></slot>
    </header>
    <main>
      <slot></slot>
    </main>
    <footer>
      <slot name="footer"></slot>
    </footer>
  </div>
```

动态插槽：v-slot:[...]或者#[...]

作用域插槽：子组件传入插槽的props做为了v-slot指令的值，可以在插槽内的表达式中访问

![微信截图_20220922113203](C:\WEB\WEB\Notes\typora-images\微信截图_20220922113203.png)

#### 14、事件监听

父子组件进行交互时，使用自定义事件，父组件通过v-on或者@来选择性监听子组件上抛的事件，子组件通过$emit传入事件名称来抛出事件；

```
父组件
<script>
 import One from './one.vue'
 export default {
 components:{ One},
  data(){
   return {
    a:1
   }
  }
 }
</script>
<template>
 <One @add="a+=1"/>
</template>
子组件
<script>
 export default {
  propps:['a'],
  emit:['add']
 }
</script>
<template>
 <div> 
  <button @click="$emit('add')">add</button>
  //也可以在组件实例上用this.$emit形式
  // methods:{submit(){this.$emit('submit')}}
 </div>
</template>
```

事件参数：

自定义事件时可以提供一个额外参数

```
<bubtton @click="$emit('add',1)"></button>
```

在父组件中监听事件，可以使用箭头函数作为监听器

```
<MyButton @add='(n) => count += n'/>
//或者使用组件方法定义一个函数
<MyButton @add='addCount'/>
methods;{
 addCount(n){
  this.count += n
 }
}
```



#### 15、动态组件

tab界面，点击切换不同组件

```
<button
 v-for="tab in tabs"
 :key="tab"
 :class="['tab-button',{active:currentTab===tab}]"
 @click="currentTab=tab"
>
 {{tab}}
</button>
<component :is="currentTab"></component>  //通过currentTab控制不同子组件的加载
```

使用`<component :is="...">`来切换组件时，被切换的组件会被卸载。可使用Keepalive保活

#### 16、find

返回通过判断的数组内第一个元素的值，没有符合条件的返回undefined

对于空数组函数不执行，没有改变数组的原始值

语法：array.find(function(currentValue,index,arr)，thisValue)

array.find((e) => e.id==query.mode)

#### 17、props && ref

一个组件需要显示声明他所接受的props，这样vue才能知道外部传入的哪些是props，哪些是attribute透传；

单向数据流：所有的props都遵循单向绑定原则，props因父组件的更新而变化，子组件也随之变化，而不会逆向传递，父组件更新后，所有的子组件中的props都会被更新到最新值。

注意：当对象或数组作为props被传入时，虽然子组件无法更改props绑定，但任然可以更改对象或数组内部的值，因为js的对象和数组是按引用传递，但禁止这样做，因为会造成很大的性能消耗，得不偿失；正确方法还是子组件抛出一个事件来通知父组件做出改变。

```
var childNode = {
 template:`<div>{{forChildMsg}}</div>`,
 props:["for-child-msg"]
};
var parentNode = {
 template :`<div>
  <child for-child-msg="aaa"></child>
  <child for-child-msg="bbb"></child>
 </div>`,
 components:{
 child:childNode
 }
};
```

子组件props声明接收变量，父组件给变量赋值

ref

`<MyComponent ref="变量名" />` 当前组件内部 `this.$refs.变量名` 访问这个子组件的实例对象,可以获取这个组件实例的属性和方法(尽量避免使用该模式,因为他会增加组件间的耦合性)

#### 18、透传attribute

指的是传递给一个组件，却没有被该组件声明为props或emits的attribute或者v-on事件监听器。常见的例子就是class、style、Id。

```
子组件
<button>1</button>
父组件
<myButton class="large"/>
渲染结果
<button class='large'>1</button>
```

这里Mybutton并没有将class声明为一个他所接受的prop，所以class被视作attribute，自动透传到了Mybutton根元素上

#### 19、v-model

组件内部标签使用

```
//等价于
<input
 :value="text"
 @input="text=$event.target.value"/>
```

当使用在一个组件上时，`<CustomInput>`组件内部需要做的两件事：

1、将原生input元素的value属性绑定到`modelValue`prop

2、输入新的值时在input元素上出发update:modelValue事件

```
父组件
data(){return{text:'11'}}
<CustomInput v-model='text'/>
子组件
<script>
export default {
 props:['modelValue'],
 emits:['update:modelValue']
}
</script>
<template>
 <input 
 :value="modelValue"
@input="$emit('update:modelValue',$event.target.value)"
 />
</template>
```

默认情况下，v-model在组件上都是使用modelvalue作为prop，并以update：modelvalue作为对应的事件。可以通过给v-model制定一个参数来更改prop名字，通过触发事件更新父组件的值。

#### 20、数组方法

##### 1、filter

filter(function)，filter把传入的函数一次作用于每个元素，根据返回的布尔值，返回TRUE的元素，过滤其他的元素；

也可以用于数组去重：

`arr.fliter((e) => self.indexOf(e) === index)`

依靠的是indexof总是返回查找到的第一个元素的索引值，重复元素因此被过滤。

##### 2、map

map(function) 返回一个新数组，数组中的元素为原始数组调用传入的函数处理之后的值；

map不会对空数组进行监测，不会改变原始数组

##### 3、concat

连接两个数组并返回结果

##### 4、find

查询符合条件的数组元素并返回第一个元素

##### 5、forEach

每个元素都执行一次传入的函数

#### 21、hash和history

##### 1、hash模式

hash模式是一种把前端路由的路径用#拼接在真实URL后面的模式。当#后面内容变化时（或刷新页面），浏览器并不会重新发起请求，不需要服务端支持，而是会触发hashchange事件。通过监听这个事件来判断路由是否发生了变化，并渲染组件

##### 2、history模式

可进行前进后退，刷新页面会重新发送请求，刷新可能存在404问题

#### 22、import as 导入模块变量

1、import 按需导入模块变量--这里在导入的时候sub变量重命名，import的时候必须使用大括号；

```
//按需引入math模块各个变量
import {del,add,sub as subList} from "@/api/math.js"
console.log(del,sub)
```

2、一次性导入全部模块变量；把所有的输出包裹到math对象里

```
//全部引入math.js模块变量
import * as math from "@/api/math.js"
console.log(math.del,math.subList)
```

3、import ... from.../import {...} from... 区别

不使用{}，import模块的命名是随意的，总会解析默认export default；

使用{}，import模块导出的模块name和export name一致

#### 23、return/break/continue

1、return关键字并不是专门用于跳出循环的，return的功能是结束一个方法。一旦在循环体内执行到一个return语句，return语句将会结束该方法，循环自然随之结束。与continue与break不同的是，return直接结束整个方法，不管这个return处于多少层循环之内；

当你需要将函数的结果返回时

2、continue功能和break有点类似，区别是continue只是中止本次循环，接着开始下一次循环。

3、break，只能在循环或者Switch语句使用，用于完全结束一个循环，跳出循环体，开始执行循环之后的代码（也可结束外循环，只需要外层循环使用标识符，break：标识符即可）

#### 24、axios封装

基本使用：安装->导入->发送请求

并发请求：axios.all

封装：

设置接口请求前缀：利用node环境变量来做判断，用于区分开发、测试、生产环境；

```
if(process.env.NODE_ENV==='development'){
axios.defaults.baseURL='http://dev.xxx.com'
}else if(process.env.NODE_ENV=='production'){
axios.defaults.baseURL='http://pro.xxx.com'
}
```

在本地调试的时候，还需要在vue.config,js文件配置devServer实现代理转发，从而实现跨域

```
devServe:{
 proxy:{
  '/proxyApi':{
   target:'http://dev.xxx.com',
   changeOrigin:true,
   pathRewrite:{  //重写，用/proxyApi代替地址
    '/proxyApi':''
   }
  }
 }
}
```

#### 25、async/await

async通过异步执行并隐式返回一个promise作为结果的函数，通过promise.resolved()将字符串封装成了一个promise对象返回；

执行到await时，函数暂停执行，直到await等待的promise状态改变了，才会回到这个函数执行。对于promise对象，await会阻塞主函数的执行，等待promise对象resolve，然后得到resolve的值，作为await表达式的运算结果，然后继续执行主函数接下来的代码。对于非promise对象，await等待函数或者直接量的返回，而不是等待执行结果；

```
function testAawait(){
 setTimeout(function(){
  console.log("textAwait");
 },1000)
}
 async function helloAsync(){
  await testAwait();
  console.log('helloAwait')
 }
  helloAsync();
  //执行结果
  heloAsync
  testAwait
```

如果promise对象为rejected,异常err被catch捕获，终止了后续代码的执行

```
function testAwait(){
 return promise.rejecte('err')
}
 async function helloAsync(){
  await testAwait();
  console.log('hello');//没有打印
 }
 helloAsync().then(v=>{
  console.log(v);
 }).catch(e=>{
 console.log(e);//err
 })
```

如何想要继续执行，可以使用try..catch

```
function testAwait(){
 return promise.rejecte('err')
}
 async function helloAsync(){
 try{
   await testAwait();
  }catch(e){
   console.log('this err:'+e);//this err:err
  }
  console.log('hello');//hello
 }
 helloAsync().then(v=>{
  console.log(v);
 }).catch(e=>{
 console.log(e);//没有打印
 })
```

#### 26、user-select:none

控制用户能否选中中文文本

#### 27、eslint禁用

1、//eslint-disable-next-line 忽略下一行

2、`/*eslint-disable*/`  忽略整个文件

#### 28、&&、||、|

&表达式两端都为真，结果才为真；

&&第一个表达式为false，结果为false，后续代码不执行

||	全假才为假

| 单竖杠： （2|0 ）单竖杠“|”运算就是转换为2进制之后相加得到的结果！



#### 29、js数组方法，改变原数组和不改变原数组

##### 1、原数组改变

1、pop()：删除数组最后一个元素，把数组长度减1，并且返回它删除的元素的值。如果数组已经为空，则pop不改变数组，并返回underfined。

2、push()：往数组尾部添加元素，直接修改数组，返回值是数组长度。

3、shift()：删除数组第一个元素，并返回删除值，如果数组已经空，同pop

4、unshift():开头添加一个或者多个，返回数组长度；

5、reserve():翻转，改变原数组排列顺序

6、sort()

7、splice()

##### 2、不改变原数组

1、concat()

2、join

3、slice：创建返回star索引和end索引之间的数组元素

4、filter：创建一个新的数组，新数组中的元素是通过指定数组中符合的条件筛选出来的。filter() 不会对空数组进行检测。 filter() 不会改变原始数组。

5、reduce

#### 30、动态切换class

`:class=“布尔值？‘类1’:‘类2’”`

追加class类名

:class="{类名1:布尔值，类名2:布尔值}"

#### 31、@close

弹窗关闭时触发

#### 32、vue :src

在vue项目中使用，动态的src，需要在引用的文件目录前面加require，否则引入的图片不生效

```
 <img :src="require('@/assets/images/company_indicator/company-tab-three0' + (index + 1) + '.png')" />
```

```
 混合三目运算符
 <img
        :src="100 >=0? require('../../assets/images/monitor/fold.png'):require('../../assets/images/monitor/unfold.png')"/>
```

路径

./表示当前目录下

../表示父级目录下

@/是webpack设置的路径别名，代表什么路径，要看webpack的build文件夹下webpack.base.conf.js里面对于@是如何配置

#### 33、动态添加样式

通过给变量赋值方式改变样式

```
:style="属性名：变量，属性名：变量"
```

伪类动态样式,用var

```
:style="--变量：变量"
css
color:var(--变量);
```

#### 34、跳转指定网址

window.open('www....','_blank')(新建网页)

#### 35、post接口和get

##### 1、get(路径拼接参数)

1、逗号分割、get请求、params作为属性

```
export function getData(data){
  return request({
    url:'www..',data,
    method:'get',
    params:data
  })
}
```

2、直接在URL加上字段

```
export function getData(code){
  return request({
    url:'www..?code='+code,
    method:'get',
    data:code
  })
}
```

3、拼数组

```
export function getData(code){
  return request({
    url:`www..?id=${code}`,
    method:'get',
  })
}
```

##### 2、post和get

get利用params传递参数

```
export function getList(data){
  return request({
    url:'www..',
    method:'get',
    params:data
  })
}
////
调用
getList({id:this.$store.id}).then(res = >{
  if( !res.error){
    data=res.data
  }else{
   alert('error')
  }
}).catch(err=>{{
  alert('error')
}})
```

post请求传参

```
export function getList(data){
  return request({
    url:'www..',
    method:'post',
    data
  })
}
///
调用
getList(this.$store.id}).then(res = >{
  if( !res.error){
    data=res.data
  }else{
   alert('error')
  }
}).catch(err=>{{
  alert('error')
}})
```

get请求

```
let params={}
this.$http.get(url,{params}).then((res)=>{})
```

post请求

```
let params={}
this.$http.post(url,params).then((res)=>{})
```



#### 36、利用递归解决树状图赋值问题

函数调用自身，在vue中调用自身需要加this

```
setCount(val) {
      for (let i = 0; i < val.length; i++) {
        let obj = val[i];
        if (
          obj.children != undefined &&
          obj.children != null &&
          obj.children.lenght != 0
        ) {
          this.setCount(obj.children);
        } else if (
          obj.resourceCode != undefined &&
          obj.resourceCode != null &&
          obj.resourceCode != ""
        ) {
          if (
            this.statistics[obj.name] != null &&
            this.statistics[obj.name] != undefined
          ) {
            obj.num = this.statistics[obj.name];
          }
        }
      }
    },
```

组件递归

思路和函数递归相同，在组件内部调用自身，

```
src/components/myTree.vue
<template>
  <div class="tree-item">
    <div v-for="item in treeData" :key="item.id">
      <div class="item-title" @click="nodeClick(item)">
        <span>{{ item.name }}</span>
        <span v-if="item.children && item.children.length">
          [{{ isOpen(item.id) ? '-' : '+' }}]
        </span>
      </div>
      <div
        v-if="item.children && item.children.length"
        v-show="isOpen(item.id)"
        class="item-childen"
      >
        <my-tree
          :treeData="item.children"
          @node-click="$emit('node-click', $event)"
        ></my-tree>
      </div>
    </div>
  </div>
</template>

<script>
export default {
  name: 'myTree',
  props: {
    treeData: {
      type: Array,
      default: () => []
    }
  },
  data() {
    return {
      expandedKeys: [] // 当前展开的节点id组成的数组
    }
  },
  methods: {
    nodeClick(item) {
      this.$emit('node-click', item)
      if (item.children && item.children.length) {
        let index = this.expandedKeys.indexOf(item.id)
        if (index > -1) {
          // 如果当前节点id存在数组中，则删除
          this.expandedKeys.splice(index, 1)
        } else {
          // 如果当前节点id不存在数组中，则添加
          this.expandedKeys.push(item.id)
        }
      }
    },
    isOpen(id) {
      // 判断节点id在不在数组中，在则显示，不在则隐藏
      return this.expandedKeys.includes(id)
    }
  }
}
</script>
src/App.vue
<template>
  <my-tree :tree-data="treeData" @node-click="nodeClick"></my-tree>
</template>

<script>
const treeData = [
  { id: 1, name: '一级1' },
  {
    id: 2,
    name: '一级2',
    children: [
      { id: 3, name: '二级2-1' },
      { id: 4, name: '二级2-2' }
    ]
  }
]
import myTree from '@/components/myTree.vue'
export default {
  components: {
    myTree
  },
  data() {
    return {
      treeData: treeData
    }
  },
  methods: {
    nodeClick(val) {
      console.log(val)
    }
  }
}
</script>
```

#### 37、minxins

混入：是一种分发vue组件中可复用功能的非常灵活的方式。混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被混入该组件本身的选项。

用法：

```
//mxinins.js
export const myMixin = {
 data (){
   return{
    mixData:'我是混入的变量'
   }
 },
 created() {
  this.hello();
 },
 methods:{
   hello( ) {
    console.log('我是混入的函数)
  },
 }
}
///组件
<template>
 <div>
   组件{mixData}
 </div>
</template>
<script>
  import {myMixin} from '@/assets/minxin.js'//直接单个界面引入，不推荐main.js全局引入
  export default {
    mixin:[myMinxin],//注册对象
    created:{
     this.mixData++;
    }
  }
</script>
```

1、混入提供给每个组件一个单独的数据或方法，在组件中改变时，不会影响到其他组件

2、当值为对象的选项时，如methods/commponents等，选项会被合并，键冲突的组件会覆盖混入对象的值；

3、值为函数的选项，如created/mounted等，就会被合并调用，混合对象里的钩子函数在组件里的钩子函数之前调用；

4、与vuex的区别

vuex：用来做状态管理的，里面定义的变量在每个组件中均可以使用和修改，在任一组件中修改此变量的值之后，其他组件中此变量的值也会随之修改。

Mixins：可以定义共用的变量，在每个组件中使用，引入组件中之后，各个变量是相互独立的，值的修改在组件中不会相互影响。

5、与公共组件的区别

组件：在父组件中引入组件，相当于在父组件中给出一片独立的空间供子组件使用，然后根据props来传值，但本质上两者是相对独立的。

Mixins：则是在引入组件之后与组件中的对象和方法进行合并，相当于扩展了父组件的对象与方法，可以理解为形成了一个新的组件。

#### 38、给对象添加新属性

a['b']=[1,2,]

```
let a={b:[1,2]}
a['c']=[3,4]
consoloe.log(a)//a{b:[1,2],c:[3,4]}
```

#### 39、vuex

引入

```
import { mapState, mapMutations, mapActions } from 'vuex' //引入映射文件
export default {
  computed: {
    ...mapState({
      // 箭头函数可使代码更简练，es6的箭头函数，传入参数是state，返回值是state.count。然后把返回值映射给count，此时调用this.count就是store里的count值
      basicList: (state) => state
    })
  },
  methods: {
    //将this.findAllBigBus()映射为this.$store.dispatch('findAllBigBus')
    ...mapActions({
      //   PushList: 'basic/PushList'
    }),
    //将this.findAllBigBus()映射为this.$store.commit('basic/findAllBigBus')	这里是分模块
    ...mapMutations({
      //映射的命名空间,basic
      PushList: 'basic/PushList'
    })
  }
}
```

#### 40、vue监听变量

在监听里面写 变量名:{ handler(newValue, oldValue) {}deep:true}

deep :设置为 true 用于监听对象内部值的变化

immediate: 设置为 true 将立即以表达式的当前值触发回调

#### 41、函数调用时加不加括号问题

1、绑定事件时

当不加括号直接调用这个函数是可以直接获取到这个事件对象的,加了()要想获取这个事件对象就要手动的加$event

```
@click=“demo” 和 @click=“demo($event)” 效果一致，但后者可以传参；
```

2、js中

函数作为参数传递不需要加括号，调用需要加，赋值时，如果不加赋值的是函数对象，加括号赋值的是函数返回值

#### 42、计算星期几

```
getWeek(val) {
      // date例如:'2022-10-25'
      var weekArray = new Array(
        "星期日",
        "星期一",
        "星期二",
        "星期三",
        "星期四",
        "星期五",
        "星期六"
      );
      var week = weekArray[new Date(val).getDay()];
    },
```

#### 43、百分比布局

外面大盒子要用百分比布局，盒子里面的小模块，可以用px设置内外边距

#### 44、转字符串

1、toString()和toLocaleString()的区别

```
//转数字，当数字是四位数以上时，
var a=1234
a.toString()
"1234"
a.toLocaleString()
"1,234"
//转换日期时
var sd = new Date()
sd
Wed Feb 15 2017 11:21:31 GMT+0800 (CST)
 
sd.toLocaleString()
"2017/2/15 上午11:21:31"
 
sd.toString()
"Wed Feb 15 2017 11:21:31 GMT+0800 (CST)"
```

#### 45、优化代码分支

使用map映射，优化多个if else

```
function speak(name){
 if(name == 'a'){
  console.log('1');
 } else if(name == 'b'){
  console.log('2');
 }else if(){}....
}
speak('a');
///优化
function speak( name){
 const map = {
  a:'1';
  b:'2';
 };
 if(map[name]){
   console.log(map[name]);
 } else {
  console.log('error');
 }
}
speak('b');
///拓展,如果对对应的是不同的操作
function speak(name){
 const map = {
  a:()=>console.log('1');
  b:()=>...具体函数
 }
 if(map[name]){
  map[name]();  //调用方法
 } else {
  console.log(error)
 }
}
//如果是更复杂的，判断条件都不一样，可以使用元组，
const map = [
 [
  ()=> name.includes('a'),
  ()=> console.log('1')
 ],
 [
  ()=> name.endWith('b') && name.length <= 3,
  ()=> console.log(name+'2')
 ],
];
const target = map.find(m=>m[0]());//遍历找到每个数组的第一项，运行条件函数作为判断条件；
if(target){
 target[1]();//找到后，返回目标数组，调用数组的第二个元素作为方法；
} else{
console.log('error')
```

注意：多个判断时

```
  if (item.warninglevelid == 1) {
              this.current1 = 0;
            } else if (item.warninglevelid == 2) {
             this.current1 = 1;
          } else if (item.warninglevelid == 3) {
              this.current1 = 2;
            } else if (item.warninglevelid == 4) {
            this.current1 = 3;
            }
优化
上面哪种方法，会导致后值覆盖前值，增加判断后，只会执行等级id大的值
  if (e.count != 0 && this.current2 < e.levelid) {
            this.current2 = e.levelid;
          }
```



#### 46、nexttick

vue 的核心思想是数据驱动视图，vue中DOM的更新是异步的，会在watcher监听数据变化之后，开启一个队列，并缓冲在同一事件循环中发生的所有数据变更，如果同一个watcher被重复触发，只会被推入队列一次，然后在下一个事件循环“tick”中，vue刷新队列并执行实际已去重的工作。

```
vue视图更新执行流程
1、vm.message = 'change' //数据更新
   Vue.nextTick(function(){})  //DOM更新之后执行函数
   console.log(vm.$el.message)//得不到结果，DOM还没有更新
    2、DOM更新
     3、nexttick的代码会在这里执行，这时候DOM已经更新了

```

第一个tick

1、首先修改数据，这是同步任务。同一个事件循环的所有同步任务都在主线程上执行，形成一个执行栈，此时还未涉及DOM。

2、vue开启一个异步队列，并缓冲在此事件循环发生的所有数据改变。如果同一个watcher被多次触发，只会被推入队列一次。

第二个tick

1、同步任务执行完毕，开始执行异步watcher队列的任务，更新DOM

第三个tick

当DOM更新循环结束之后，此时调用下一个task执行，也就是nexttick中注册的延迟回调。

#### 47、图片上传功能

1、实现思路

前端将图片发送到后端，后端将图片存到服务器，然后返回存储图片的地址到前端，前端通过图片地址回显图片。

```
upload() {
  let that = this;//防止this指向改变
  let formdData = new FormData;//创建一个新的FormData对象。
  formData.append('属性名',属性值);
  that.$axios.default.baseUrl = 'http..'//服务器基础路径
  that.$axios({
    method:'post',
    url:'/a/b,
    data:formData,
    headers:{"Content-Type":"multipart/form-data"}//设置Content-Type类型
  }).then((result)=> {
  that.urls = result.data;
  });
},
```



#### 48、return和break

1、return

**`return`** 语句终止函数的执行，并返回一个指定的值给函数调用者。

```
function testBreak(x) {
  var i = 0;

  while (i < 6) {
    if (i == 3) {
      return;
    }
    i += 1;//不执行
  }
  console.log( i * x);//不执行
}
```

2、break

**break 语句**中止当前循环，[`switch`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/switch)语句或[`label`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/label) 语句，并把程序控制流转到紧接着被中止语句后面的语句。

break 语句不能在 function 函数体中直接使用，break 语句应嵌套在要中断的当前循环、switch 或 label 语句中。

```
 function testBreak(x) {
  var i = 0;

  while (i < 6) {
    if (i == 3) {
      break;
    }
    i += 1;//不执行
  }

  return i * x;//执行
}
```

#### 49、打包

npm run build

#### 50、:visible.sync

:visible指的是属性绑定，表示弹框的显示隐藏，当为TRUE显示；后面的sync指的是同步动态双向的来表示visible的值，当关闭窗口，visible值发生变化，但是我们没法用确定的动作去判断这个值，所以用到了vue双向绑定的原则，在vue中统一加上了sync来表示同步的修改visible的值。

我们把`<Child :money="total" v-on:update:money="total = $event" />`这行简化一下变成`<Child :money.sync="total" />`就可以了，与上面一行完全等价。

这就是 Vue 的 .sync 修饰符的作用。

#### 60、computer

不懂如何使用以及不理解return；习惯性思维，data声明，调用时赋值；

正确使用：计算一些复杂的数据处理，不需要在data声明，直接return出去计算结果，在要结果数据的位置调用函数即可。

#### 61、Object.valules()

方法返回一个给定对象自身的所有可枚举属性值的数组，值得顺序与使用for in循环的顺序相同（区别在于for in循环枚举原型链中的属性）

#### 62.Object.keys()

方法返回一个由一个给定对象自身可枚举属性名组成的数组，数组中属性名的序列顺序和正常遍历该对象时返回的顺序一致。

#### 63、数组变量赋值为空

1、this.arr=[]  后面监听将不会监听此变量的变化

2、this.arr.splice(0) 可以使用splice解决

#### 64、组件封装

通用组件往往不能够完美适应与所有场景，在封装组件时，只需要完成公用的部分，剩下的不同部分使用插槽解决。

```
子组件
<div class="child">
  //具名插槽
  <slot name="button"</slot>
  //匿名插槽
  <slot></slot>
</div>
父组件
<child>
 <button slot="button"></button>
</child>
```

#### 65、promise.all

promise.all解决多个请求并发执行，并且有错误还能按顺序执行并输出。

- promise.all()接收一个promise对象组成的数组作为参数，并返回一个新的promise对象。
- 当数组中所有的对象都resolve时，新对象状态变为fulfilled，所有对象的resolve的value依次添加组成一个新的数组，并以新的数组作为新对象resolve的value。
- 当数组中有一个对象reject时，新对象状态变为rejected，并以当前对象请求reject的reason作为新对象reject的reason。

#### 66、匿名函数

普通函数和匿名函数的区别

```
//普通函数
function sum(a,b){
   return a+b;
   console.log('普通函数')
}
//匿名函数，不能单独使用
function (a,b){
   retunr a+b;
   console.log('匿名函数')
}
```

注意：匿名函数不能单独使用，使用场景如下：

1. 用于函数表达式

   ```
   var sum = function (a,b){
        return a+b;
   };
   ```

2. 作为返回值

   ```
   function sum(a,b) {
      return function () {
         return a+b;
      };
   };
   console.log(sum(2,3));//[function]
   console.log(sum(2,3)();)//5
   ```

3. 用于定义对象方法

   ```
   var obj = {
       name:'name',
       func:function (){
          console.log(this.name)
        }
   };
   obj.func();    
   ```

4. 作为回调函数

   ```
   setTimeout (function(){
     console.log('1')
   },1000)
   ```

5. 用于立即执行函数

   ```
   常用形式一：名函数后面跟一个括号，再将整个包裹在一个括号运算符中
   (function() {
   console.log('立即执行函数是基于匿名函数创建的');
   }());
   
   常用形式二：将匿名函数包裹在一个括号运算符中，后面再跟一个括号
   (function () {undefined
   console.log('立即执行函数');
   })();
    // !!!特别说明：若此立即执行函数后面立马又跟着一个立即执行函数，一定要在结尾加分号，否则后面的立即执行函数会报错！
   ```

6. 用于DOM元素

   ```
   <button id="btnEvent">click me</button>
   let btn=docunment.getElementById("btnEvent")
   btn.onclick=function(){
   	console.log("DOM元素注册时间")
   	}
   ```

   

#### 67、解决更改部分数据需要重新打包部署问题

1、打包后，dist文件夹中，static文件夹依然存在，在该文件夹内些配置文件，需要更改时，直接更改即可，无需重新打包部署。

#### 68、js文件暴露

```
//js文件暴露练习
//方法一
function add() {
  console.log("helloWord add");
}
var a = 9;
var obj = {
  a: 1,
  b: 3,
  c: 5,
};
export { add, a, obj };
//import { add, a, obj } from "./js/tool";引入方法
//方法二
// export var a = 10;
// export function fun() {
//   console.log("function");
// }
//方法三 export default
// var a = {
//   fun: function () {
//     console.log("default");
//   },
//   a: 3,
//   obj: {
//     a: 1,
//     b: 2,
//     c: 3,
//   },
// };
// export default a;
//export default 只能存在一个 导入时不需要加{}，export可以存在多个导入，导入一定要加{}
//as关键字 在导入的时候将数据存储到新的对象名中使用
//export { a, b, c }
//import * as obj from 'js'  相当于把a, b, c存在了obj中
//import {a as obj} from 'js  将a重命名为obj
//都存在
// var a = 1;
// var b = 2;
// var c = 3;
// export { a as default, b, c };
//import x,{b,c} from 'js'   默认暴露可以随意命名，

```



#### 69、js文件全局引入

```
import xxx from './xxx/xxx.js'

Vue.prototype.$xxx =xxx;
//
使用：this.$xxx
```

#### 70、build

项目中没有build文件夹：

和vue-cli版本有关，首先这个文件是存在的，但是被隐藏了（官方隐藏的），正常开发是不需要配置的，如果你想做配置就新建vue.config.js，在这个文件里面写你的配置。

